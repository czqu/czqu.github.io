<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name="description" content="核心知识点
"><meta name="keywords" content="czq's Blog,  博客, 个人网站, 互联网, java,Linux,Web"><meta name="theme-color" content="#000000"><meta property="og:title" content="算法与数据结构学习笔记：链表 - Czq's Blog"><meta property="og:type" content="article"><meta property="og:description" content="核心知识点
"><meta property="article:published_time" content="2020-07-24T20:01:00Z"><meta property="article:author" content="czqu"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="算法"><meta property="article:tag" content="链表"><meta property="article:tag" content="cpp"><meta property="og:image" content="https://czqu.cc/img/avatar-boy.webp"><meta property="og:url" content="https://czqu.cc/algorithm/data-structure/linked_list.html"><meta property="og:site_name" content="Czq's Blog"><title>算法与数据结构学习笔记：链表 - Czq's Blog</title><link rel="manifest" href="/pwa/manifest.json"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://czqu.cc/algorithm/data-structure/linked_list.html"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/hux-blog.min.css"><link href="/css/font-awesome.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script></script></head><body ontouchstart=""><script src="/js/qin-blog.js" type="text/javascript"></script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">Czq's Blog</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/archive/">Archive</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse"),__HuxNav__={close:function(){$navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)},open:function(){$collapse.style.height="auto",$navbar.className+=" in"}};$toggle.addEventListener("click",function(e){0<$navbar.className.indexOf("in")?__HuxNav__.close():__HuxNav__.open()}),document.addEventListener("click",function(e){e.target!=$toggle&&"icon-bar"!=e.target.className&&__HuxNav__.close()})</script><style type="text/css">header.intro-header{position:relative;background-image:url(/img/home-bg-notdimmed.webp)}</style><header class="intro-header"><div class="header-mask"></div><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="数据结构">数据结构</a> <a class="tag" href="/archive/?tag=%E7%AE%97%E6%B3%95" title="算法">算法</a> <a class="tag" href="/archive/?tag=%E9%93%BE%E8%A1%A8" title="链表">链表</a> <a class="tag" href="/archive/?tag=cpp" title="cpp">cpp</a></div><h1>算法与数据结构学习笔记：链表</h1><h2 class="subheading"></h2><span class="meta">Posted by czqu on July 24, 2020</span></div></div></div></div></header><article><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><h3 id="核心知识点">核心知识点</h3><ul><li><p>null异常处理</p></li><li><p>dummy node 哑巴节点</p></li><li><p>双指针/快慢指针</p></li><li><p>插入一个节点到排序链表</p></li><li><p>从一个链表中移除一个节点</p></li><li><p>翻转链表</p></li><li><p>合并两个链表</p></li><li><p>找到链表的中间节点</p></li></ul><h3 id="例题">例题：</h3><h4 id="83-删除排序链表中的重复元素"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3</p></blockquote><h5 id="直接法"><strong>直接法：</strong></h5><p>链表是有序的，所以直接更改当前结点的 next 指针，跳过下一个结点并直接指向下一个结点之后的结点即可。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">deleteDuplicates</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">current</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="c1">//null异常处理</span>
        <span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//一直删除，直到下一个不重复 </span>
            <span class="c1">// 想想如果把while改成if怎么样</span>
            <span class="c1">//把current-&gt;next!=NULL删除会怎么样</span>
            <span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">==</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//移动到下一个节点</span>
            <span class="n">current</span><span class="o">=</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>


    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><ul><li><p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n是列表中的结点数。</p></li><li><p>空间复杂度：O(1)，没有使用额外的空间。</p></li></ul><h4 id="82-删除排序链表中的重复元素-ii"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h4><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 输出: 1-&gt;2-&gt;5 示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3 输出: 2-&gt;3</p></blockquote><h5 id="利用哑结点"><strong>利用哑结点</strong>：</h5><p>为了防止删除头结点的极端情况发生，先创建空结点dummy，使dummy指向传入的head结点。</p><p>然后创建一个cur指针指向dummy，比较cur的后两个结点，看他们是否相同。</p><p>如果相同，则说明cur后有重复元素，此时创建一个temp指针指向第一个重复元素，即cur-&gt;next;</p><p>通过循环进行去重，循环结束后temp指向的是这群重复元素的最后一个，依照题意此时temp的下一个才是我们想要的。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">deleteDuplicates</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//设置哑结点 防止删除头结点的情况发生后的问题</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">dummy</span><span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span><span class="o">=</span><span class="n">dummy</span><span class="p">;</span><span class="c1">//cur 指向哑结点</span>

        <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//比较cur后两个结点</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">==</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//去重</span>
                <span class="n">ListNode</span> <span class="o">*</span><span class="n">temp</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="k">while</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">==</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">temp</span><span class="o">=</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">//temp前的重复结点都跳过了，现在我们跳过temp</span>
                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="c1">//如果cur后两个结点不重复，直接前移</span>
                <span class="n">cur</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><h4 id="206-反转链表"><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><blockquote><p>反转一个单链表。</p><p><strong>示例:</strong></p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><h5 id="双指针">双指针</h5><p>如图，定义两个指针，pre在前 cur在后,temp 保存向前的pre指针的临时指针</p><p>每次进行一次局部翻转，</p><p>当pre到达尾部的时候终止，此时cur指向最后一个节点。</p><p><img src="../../../img/in-post/2020-7-12-linked_list/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif" alt="img"></p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*定义两个指针，pre在前 cur在后
         *当pre到达尾部的时候终止，此时cur指向最后一个节点
         */</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">pre</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">temp</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span><span class="c1">//临时存储pre</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="c1">//pre指向下一个节点</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span><span class="c1">//翻转指针</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span><span class="c1">//cur指针向前移动一步</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="92-反转链表-ii"><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><blockquote><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p><p><strong>示例:</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
</pre></td></tr></tbody></table></code></pre></div></div></blockquote><h5 id="迭代法">迭代法：</h5><p>参考上题，先遍历到 m 处，再翻转</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseBetween</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">pre</span><span class="p">,</span><span class="o">*</span><span class="n">cur</span><span class="p">;</span>
        <span class="n">pre</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        
		<span class="c1">//遍历到m节点，如果只有一个节点，跳过，这里cur会为空但是后面翻转链表的时候就不是了</span>
        <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">m</span><span class="o">--</span><span class="p">;</span>
            <span class="n">n</span><span class="o">--</span><span class="p">;</span>
            
        <span class="p">}</span>

		<span class="c1">//m节点的前一个节点</span>
        <span class="n">ListNode</span><span class="o">*</span><span class="n">con</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span><span class="n">temp</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">//用于保存被翻转链表的第一个节点</span>
        <span class="n">ListNode</span><span class="o">*</span><span class="n">front</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
        
      
        
		<span class="c1">//反转m-n的节点</span>
        <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        
		<span class="c1">//如果不只是一个节点，那么就把指针指向被翻转的链表的最后一个节点</span>
        <span class="k">if</span><span class="p">(</span><span class="n">con</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">con</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">//否则直接输出此节点</span>
            <span class="n">head</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//被翻转的链表原来的头变尾</span>
        <span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="21-合并两个有序链表"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h5 id="迭代法-1">迭代法：</h5><p>直接连接各个节点</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">dummy</span><span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span><span class="o">=</span><span class="n">dummy</span><span class="p">;</span>
        <span class="c1">//将小的节点接到哑结点为头的链表中</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l1</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">l2</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&gt;</span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
               <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l2</span><span class="p">;</span>
               <span class="n">cur</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
               <span class="n">l2</span><span class="o">=</span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l1</span><span class="p">;</span>
                <span class="n">cur</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">l1</span><span class="o">=</span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="p">}</span>
        
        <span class="c1">//处理剩下的节点</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l1</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l2</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="86-分隔链表"><a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a></h4><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p>示例:</p><p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><p><strong>当头节点不确定的时候，使用哑巴节点</strong></p><p>将大于 x 的节点，放到另外一个链表，最后连接这两个链表</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">partition</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">headDummy</span><span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">tailDummy</span><span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="o">*</span><span class="n">tail</span><span class="o">=</span><span class="n">tailDummy</span><span class="p">;</span>
        <span class="n">headDummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        
        <span class="n">head</span><span class="o">=</span><span class="n">headDummy</span><span class="p">;</span>
		
        <span class="k">while</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;</span><span class="n">x</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//这里把大于X的节点删除，然后连接到另一个链表</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">cur</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="c1">//删除大于X的节点</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="c1">//连接到新链表</span>
                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
                <span class="n">tail</span><span class="o">=</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>


            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//拼接两个链表</span>
        <span class="c1">//tail代表tailDummy最后一个节点，它的后面可能还连着，要断掉</span>
        <span class="c1">//如输入[1,4,3,2,5,2]就会有错,没有处理5-&gt;2</span>
        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">tailDummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">headDummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="876-链表的中间结点"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><blockquote><p>给定一个带有头结点 <code class="language-plaintext highlighter-rouge">head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p></blockquote><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">middleNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span><span class="p">,</span><span class="o">*</span><span class="n">fast</span><span class="p">;</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
       <span class="p">{</span>
           <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
           <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>总结：如果链表长度是偶数，返回中间偏右的位置</p><p>且fast如果初始化为head-&gt;next 返回中间偏左的位置。</p><p>奇数长度则两者相同。</p><h4 id="148-排序链表"><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><blockquote><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><p>输入: 4-&gt;2-&gt;1-&gt;3 输出: 1-&gt;2-&gt;3-&gt;4 示例 2:</p><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0 输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h5 id="递归">递归</h5><p>归并排序链表，找中点和合并操作</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="c1">//寻找链表中点，快慢指针，快的到达终点，慢的刚好到中点 </span>
    <span class="c1">//当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：</span>
    <span class="c1">//此题我们让head先走，则停在中间偏左的位置</span>
    <span class="c1">//148 143 141都有快慢指针</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">findMiddle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span><span class="p">,</span><span class="o">*</span><span class="n">fast</span><span class="p">;</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>

        <span class="p">{</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//合并两个链表，参考归并排序</span>
    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="n">left</span><span class="p">,</span><span class="n">ListNode</span><span class="o">*</span><span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">dummy</span><span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="o">=</span><span class="n">dummy</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">right</span><span class="p">;</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">left</span><span class="p">;</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>   
            <span class="c1">//下一个</span>
            <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//处理剩下节点</span>
        <span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">left</span><span class="p">;</span>
                <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">while</span><span class="p">(</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">right</span><span class="p">;</span>
                <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
	
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">mergeSort</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="o">||</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">middle</span><span class="o">=</span><span class="n">findMiddle</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

        <span class="c1">// 断开中间节点</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail</span><span class="o">=</span><span class="n">middle</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">middle</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">//左右分别进行归并排序</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">left</span><span class="o">=</span><span class="n">mergeSort</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">right</span><span class="o">=</span><span class="n">mergeSort</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">res</span><span class="o">=</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="143-重排链表"><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h4><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p></blockquote><p>此题目为2019年计算机统考408真题</p><p>思路：找到中点断开，翻转后面部分，然后合并前后两个链表</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    
    <span class="c1">//快慢指针找中点，同上一题 </span>
    <span class="c1">//148 143 141都有快慢指针</span>
    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">findMiddle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span><span class="p">,</span><span class="o">*</span><span class="n">fast</span><span class="p">;</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="c1">//如果是偶数个节点，返回中间偏右的位置 </span>
        <span class="c1">//你改成fast=head-&gt;next返回中间偏左也是对的</span>
        <span class="c1">//有趣吧，画个图就知道了</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>

    <span class="p">}</span>
    
    <span class="c1">//合并两个链表</span>
    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">l1</span><span class="p">,</span><span class="n">ListNode</span><span class="o">*</span><span class="n">l2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummy</span><span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">bool</span>  <span class="n">toggle</span> <span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="o">=</span><span class="n">dummy</span><span class="p">;</span>
        <span class="c1">//间断连接两个链表</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l1</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">l2</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">toggle</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l1</span><span class="p">;</span>
                <span class="n">l1</span><span class="o">=</span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l2</span><span class="p">;</span>
                <span class="n">l2</span><span class="o">=</span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">toggle</span><span class="o">=!</span><span class="n">toggle</span><span class="p">;</span>
            <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//连接剩下的节点</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l1</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l1</span><span class="p">;</span>
            <span class="n">l1</span><span class="o">=</span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l2</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">l2</span><span class="p">;</span>
            <span class="n">l2</span><span class="o">=</span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">reorderList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="o">||</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">;</span>
        
        <span class="c1">//找到中点 断开</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">middle</span><span class="o">=</span><span class="n">findMiddle</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">tail</span><span class="o">=</span><span class="n">middle</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">middle</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">//翻转链表</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span><span class="o">*</span><span class="n">pre</span><span class="p">;</span>
        <span class="n">pre</span><span class="o">=</span><span class="n">tail</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">temp</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tail</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
        
        <span class="c1">//合并链表</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="n">tail</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>                
    <span class="p">}</span>
    
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="141-环形链表"><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p></blockquote><blockquote><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1</p><p>输出：true</p><p>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><img src="../../../img/in-post/2020-7-12-linked_list/circularlinkedlistss.png" alt="img"></p><p>示例 2：</p><p>输入：head = [1,2], pos = 0</p><p>输出：true</p><p>解释：链表中有一个环，其尾部连接到第一个节点。</p><p><img src="../../../img/in-post/2020-7-12-linked_list/circularlinkedlist_test2.png" alt="img"></p><p>示例 3：</p><p>输入：head = [1], pos = -1 输出：false 解释：链表中没有环。</p><p><img src="../../../img/in-post/2020-7-12-linked_list/circularlinkedlist_test3.png" alt="img"></p></blockquote><p>快慢指针即可，就像你在操场跑步，操场有环，只要你和她速度不一样，你们总能与她相遇，如果是直线，她到了终点，你就再也追不上她</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="c1">//148 143 141 142都有快慢指针</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">hasCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">fast</span><span class="p">,</span><span class="o">*</span><span class="n">slow</span><span class="p">;</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="c1">// 比较指针是否相等</span>
            <span class="k">if</span><span class="p">(</span><span class="n">slow</span><span class="o">==</span><span class="n">fast</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="142-环形链表-ii"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 ：</p><p>输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。</p><p><img src="../../../img/in-post/2020-7-12-linked_list/circularlinkedlist.png" alt="img"></p></blockquote><p>。</p><h5 id="floyd-算法">Floyd 算法</h5><p>你在操场跑步，操场有环，只要你和她速度不一样，你们总能与她相遇，如果是直线，她到了终点，你就再也追不上她。此题分为两个阶段，第一个阶段先用快慢指针测试是否有环，第二阶段慢指针回到头head,然后各自以相同速度前进，相遇点即为入环处（可以自己画图尝试）。严格的数学证明可参考leetcode官方题解。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">detectCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span><span class="p">,</span><span class="o">*</span><span class="n">fast</span><span class="p">;</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="p">;</span><span class="c1">//如果这里是fast=fast-&gt;next，那么下面该怎么改？</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">slow</span><span class="o">==</span><span class="n">fast</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//回到起点，各自以相同速度前进</span>
                <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
                <span class="k">while</span><span class="p">(</span><span class="n">slow</span><span class="o">!=</span><span class="n">fast</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

                <span class="p">}</span>
                <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
            <span class="p">}</span>                        
        <span class="p">}</span>     
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="234-回文链表"><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h4><blockquote><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>输入: 1-&gt;2
输出: false
</pre></td></tr></tbody></table></code></pre></div></div><p><strong>示例 2:</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>输入: 1-&gt;2-&gt;2-&gt;1
输出: true
</pre></td></tr></tbody></table></code></pre></div></div></blockquote><p>先找到链表中点，然后后面的翻转链表，一个个比较。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isPalindrome</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="o">||</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span><span class="p">,</span><span class="o">*</span><span class="n">fast</span><span class="p">;</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//偶数长度slow是中间偏左的节点</span>
        <span class="c1">//奇数长度slow是中点</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span><span class="o">*</span><span class="n">pre</span><span class="p">,</span><span class="o">*</span><span class="n">tail</span><span class="p">,</span><span class="o">*</span><span class="n">temp</span><span class="p">;</span>
		<span class="c1">//分离两个链表</span>
        <span class="n">tail</span><span class="o">=</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
		<span class="c1">//翻转链表</span>
        <span class="n">pre</span><span class="o">=</span><span class="n">tail</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pre</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//原链表的最后一个节点现在变成头结点</span>
        <span class="n">tail</span><span class="o">=</span><span class="n">cur</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">head</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">tail</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">!=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">tail</span><span class="o">=</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><h4 id="138-复制带随机指针的链表"><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h4><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。</p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。</p></blockquote><p>复制节点跟在原节点后面即可</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="rouge-code"><pre><span class="cm">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">copyRandomList</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">cur</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="c1">//复制节点到后面</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">clone</span><span class="o">=</span><span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">clone</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">clone</span><span class="o">-&gt;</span><span class="n">random</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">random</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">clone</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">clone</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
         <span class="c1">//处理random指针</span>
        <span class="n">cur</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">random</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">random</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">random</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//分离链表</span>
        <span class="n">cur</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">cloneHead</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">temp</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
            
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cloneHead</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div><hr style="visibility:hidden"><ul class="pager"><li class="previous"><a href="/compile-7zip.html" data-toggle="tooltip" data-placement="top" title="7zip的编译">Previous<br><span>7zip的编译</span></a></li><li class="next"><a href="/using-rest-client-in-idea.html" data-toggle="tooltip" data-placement="top" title="Rest Client在idea的使用">Next<br><span>Rest Client在idea的使用</span></a></li></ul><hr style="visibility:hidden"><div id="disqus_comment" class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container"><div class="side-catalog"><hr class="hidden-sm hidden-xs"><h5><a class="catalog-toggle" href="#">CATALOG</a></h5><ul class="catalog-body"></ul></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><div class="dropdown navbar-form navbar-right"><input id="search-input" name="word" type="text" aria-haspopup="true" aria-expanded="false" data-toggle="dropdown" class="form-control typeahead" placeholder="搜索"><ul class="dropdown-menu" aria-labelledby="dLabel" id="results-container"></ul></div><script src="/js/simple-jekyll-search.js" type="text/javascript"></script><script>window.simpleJekyllSearch=new SimpleJekyllSearch({searchInput:document.getElementById("search-input"),resultsContainer:document.getElementById("results-container"),json:"/search.json",searchResultTemplate:'<li><a href="{url}" title="{desc}">{title}</a></li>',noResultsText:"没有搜索到文章",limit:20,fuzzy:!0})</script><section><hr class="hidden-sm hidden-xs"><h5><a href="/archive/">FEATURED TAGS</a></h5><div class="tags"><a data-sort="0023" href="/archive/?tag=Linux" title="Linux" rel="3">Linux</a> <a data-sort="0018" href="/archive/?tag=cpp" title="cpp" rel="8">cpp</a> <a data-sort="0020" href="/archive/?tag=%E5%90%8E%E7%AB%AF" title="后端" rel="6">后端</a> <a data-sort="0020" href="/archive/?tag=%E7%AE%97%E6%B3%95" title="算法" rel="6">算法</a> <a data-sort="0022" href="/archive/?tag=%E6%80%A7%E8%83%BD" title="性能" rel="4">性能</a> <a data-sort="0022" href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="数据结构" rel="4">数据结构</a> <a data-sort="0022" href="/archive/?tag=mysql" title="mysql" rel="4">mysql</a> <a data-sort="0024" href="/archive/?tag=%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8" title="信息安全" rel="2">信息安全</a> <a data-sort="0024" href="/archive/?tag=%E5%89%8D%E7%AB%AF" title="前端" rel="2">前端</a> <a data-sort="0024" href="/archive/?tag=java" title="java" rel="2">java</a> <a data-sort="0024" href="/archive/?tag=kali" title="kali" rel="2">kali</a> <a data-sort="0024" href="/archive/?tag=linux" title="linux" rel="2">linux</a></div></section><hr><h5>FRIENDS</h5><ul class="list-inline"><li><a href="https://2084team.cn/">2084 Team</a></li></ul></div></div><div class="row"><div id="gitmentContainer"></div><script src="/js/gitment.browser.js"></script><link rel="stylesheet" href="/css/default.css"></div></div></article><script type="text/javascript">var disqus_shortname="donaldxy",disqus_identifier="/algorithm/data-structure/linked_list",disqus_url="https://czqu.cc/algorithm/data-structure/linked_list.html";!function(){if(is_global){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}else document.getElementById("disqus_comment").style.display="none"}()</script><script>if(is_global)document.getElementById("gitmentContainer").style.display="none";else{var gitment=new Gitment({id:"/algorithm/data-structure/linked_list.html",owner:"czqu",repo:"czqu.github.io",oauth:{client_id:"23a9781cae2172c5d591",client_secret:"4493f8b5c72f024f1a7b79d556b7e43599f918ed"}});gitment.render("gitmentContainer")}</script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("/js/anchor.min.js",function(){anchors.options={visible:"hover",placement:"right"},anchors.add().remove(".intro-header h1").remove(".subheading").remove(".sidebar-container h5")})</script><style>@media all and (min-width:800px){.anchorjs-link{position:absolute;left:-.75em;font-size:1.1em;margin-top:-.1em}}</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a id="rss" href="/feed.xml"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a target="_blank" href="https://www.zhihu.com/people/czqu"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-stack-1x fa-inverse">知</i></span></a></li><li><a target="_blank" href="https://blog.csdn.net/weixin_44409903"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-stack-1x fa-inverse">C</i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Czq's Blog 2020<br><a id="switchsite" href="https://blog.xiyuan.ren/">国内访问</a> &nbsp; &nbsp;&nbsp; <a href="/license.html">许可协议 License</a><br><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">&nbsp;本站总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;次&nbsp;</span><span id="busuanzi_container_site_uv"> &nbsp;访客数&nbsp;<span id="busuanzi_value_site_uv"></span>&nbsp;人次</span><script type="text/javascript">var linkobj=document.getElementById("switchsite");current_url=window.location.href,is_global?(target_url=replacedomain(current_url,document.domain,"blog.czqu.ren"),linkobj.href=target_url,linkobj.innerText="国内访问"):(target_url=replacedomain(current_url,document.domain,"czqu.cc"),linkobj.href=target_url,linkobj.innerText="海外访问")</script></p></div></div></div></footer><script src="/js/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/hux-blog.min.js"></script><script src="/js/snackbar.js"></script><script src="/js/sw-registration.js"></script><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("/js/fastclick.min.js",function(){var c=document.querySelector("nav");c&&FastClick.attach(c)})</script><script>var _gaId="UA-171260366-1",_gaDomain="czqu.cc";_gaDomain=is_global?(_gaId="UA-171260366-1","czqu.cc"):(_gaId="UA-171260366-2","blog.czqu.ren"),function(a,e,g,c,n,o,t){a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,o=e.createElement(g),t=e.getElementsByTagName(g)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(o,t)}(window,document,"script",0,"ga"),ga("create",_gaId,_gaDomain),ga("send","pageview")</script><script>var _baId="202567f05f85026a62a117eec19b4a09",linkobj=document.getElementById("switchsite");_baId=is_global?"202567f05f85026a62a117eec19b4a09":"496677e3ceac55257d74003c6c3c2f3b";var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?"+_baId;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(e,a)}()</script><script type="text/javascript">function generateCatalog(e){var a,l,n,t,o,c;return _containerSelector="div.post-container",a=$(_containerSelector).find("h1,h2,h3,h4,h5,h6"),$(e).html(""),a.each(function(){l=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),c=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),t=$('<li class="'+l+'_nav"></li>').append(c),$(e).append(t)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),async("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><img src="/img/icon_wechat.png" width="0" height="0"></body></html>